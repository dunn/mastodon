replicaCount: 1

image:
  repository: tootsuite/mastodon
  pullPolicy: Always
  # https://hub.docker.com/r/tootsuite/mastodon/tags
  tag: v3.1.4
  # alternatively, use `latest` for the latest release or `edge` for the image
  # built from the most recent commit
  #
  # tag: latest

ingress:
  enabled: false
  annotations:
    kubernetes.io/ingress.class: nginx
    kubernetes.io/tls-acme: "true"
    # cert-manager.io/cluster-issuer: "letsencrypt"
  # this value is used for LOCAL_DOMAIN
  hostname: mastodon.local
  tls:
    - secretName: mastodon-tls
      hosts:
        - mastodon.local

service:
  type: ClusterIP
  port: 80

application:
  port: 3000

streaming:
  port: 4000

sidekiq:
  concurrency: 25

# https://github.com/bitnami/charts/tree/master/bitnami/elasticsearch#parameters
elasticsearch:
  # `false` will disable full-text search
  #
  # if you enable ES after the initial install, you will need to manually run
  # RAILS_ENV=production bundle exec rake chewy:sync
  # (https://docs.joinmastodon.org/admin/optional/elasticsearch/)
  enabled: true
  # may be removed once https://github.com/tootsuite/mastodon/pull/13828 is part
  # of a tagged release
  image:
    tag: 6

# https://github.com/bitnami/charts/tree/master/bitnami/postgresql#parameters
postgresql:
  postgresqlDatabase: mastodon_production
  # you must set a password; the password generated by the postgresql chart will
  # be rotated on each upgrade:
  # https://github.com/bitnami/charts/tree/master/bitnami/postgresql#upgrade
  postgresqlPassword: ""
  postgresqlUsername: postgres

# https://github.com/bitnami/charts/tree/master/bitnami/redis#parameters
redis:
  # you must set a password; the password generated by the redis chart will be
  # rotated on each upgrade:
  password: ""

environment:
  # these must be set manually; autogenerated secrets are rotated on each
  # upgrade
  secret:
    OTP_SECRET: ""
    SECRET_KEY_BASE: ""
    SMTP_PASSWORD: ""
    VAPID_PRIVATE_KEY: ""
    VAPID_PUBLIC_KEY: ""
  public:
    # available locales:
    # https://github.com/tootsuite/mastodon/blob/master/config/application.rb#L43
    DEFAULT_LOCALE: en
    ES_PORT: 9200
    # https://devcenter.heroku.com/articles/tuning-glibc-memory-behavior
    MALLOC_ARENA_MAX: "2"
    NODE_ENV: production
    RAILS_ENV: production
    SMTP_AUTH_METHOD: login
    SMTP_DELIVERY_METHOD: smtp
    SMTP_ENABLE_STARTTLS_AUTO: "true"
    SMTP_FROM_ADDRESS: notifications@example.com
    SMTP_LOGIN: ""
    SMTP_PORT: 587
    SMTP_SERVER: smtp.example.com
    # this should be set manually since os.cpus() returns the number of CPUs on
    # the node running the pod, which is unrelated to the resources allocated to
    # the pod by k8s
    STREAMING_CLUSTER_NUM: 1

persistence:
  assets:
    # ReadWriteOnce is more widely supported than ReadWriteMany, but limits
    # scalability, since it requires the Rails and Sidekiq pods to run on the
    # same node.
    accessMode: ReadWriteOnce
    resources:
      requests:
        storage: 100Gi
  system:
    accessMode: ReadWriteOnce
    resources:
      requests:
        storage: 10Gi

# https://github.com/tootsuite/mastodon/blob/master/Dockerfile#L88
#
# if you manually change the UID/GID environment variables, ensure these values
# match:
podSecurityContext:
  runAsUser: 991
  runAsGroup: 991
  fsGroup: 991

securityContext: {}

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}
